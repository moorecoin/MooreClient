package org.ripple.bouncycastle.openpgp.examples;

import java.io.bufferedinputstream;
import java.io.bufferedoutputstream;
import java.io.fileinputstream;
import java.io.fileoutputstream;
import java.io.ioexception;
import java.io.inputstream;
import java.io.outputstream;
import java.security.nosuchproviderexception;
import java.security.securerandom;
import java.security.security;

import org.ripple.bouncycastle.bcpg.armoredoutputstream;
import org.ripple.bouncycastle.bcpg.compressionalgorithmtags;
import org.ripple.bouncycastle.jce.provider.bouncycastleprovider;
import org.ripple.bouncycastle.openpgp.pgpcompresseddata;
import org.ripple.bouncycastle.openpgp.pgpencrypteddata;
import org.ripple.bouncycastle.openpgp.pgpencrypteddatagenerator;
import org.ripple.bouncycastle.openpgp.pgpencrypteddatalist;
import org.ripple.bouncycastle.openpgp.pgpexception;
import org.ripple.bouncycastle.openpgp.pgpliteraldata;
import org.ripple.bouncycastle.openpgp.pgpobjectfactory;
import org.ripple.bouncycastle.openpgp.pgppbeencrypteddata;
import org.ripple.bouncycastle.openpgp.pgputil;
import org.ripple.bouncycastle.openpgp.operator.jcajce.jcapgpdigestcalculatorproviderbuilder;
import org.ripple.bouncycastle.openpgp.operator.jcajce.jcepbedatadecryptorfactorybuilder;
import org.ripple.bouncycastle.openpgp.operator.jcajce.jcepbekeyencryptionmethodgenerator;
import org.ripple.bouncycastle.openpgp.operator.jcajce.jcepgpdataencryptorbuilder;
import org.ripple.bouncycastle.util.io.streams;

/**
 * a simple utility class that encrypts/decrypts password based
 * encryption files.
 * <p>
 * to encrypt a file: pbefileprocessor -e [-ai] filename passphrase.<br>
 * if -a is specified the output file will be "ascii-armored".<br>
 * if -i is specified the output file will be "integrity protected".
 * <p>
 * to decrypt: pbefileprocessor -d filename passphrase.
 * <p>
 * note: this example will silently overwrite files, nor does it pay any attention to
 * the specification of "_console" in the filename. it also expects that a single pass phrase
 * will have been used.
 */
public class pbefileprocessor
{
    private static void decryptfile(string inputfilename, char[] passphrase)
        throws ioexception, nosuchproviderexception, pgpexception
    {
        inputstream in = new bufferedinputstream(new fileinputstream(inputfilename));
        decryptfile(in, passphrase);
        in.close();
    }

    /*
     * decrypt the passed in message stream
     */
    private static void decryptfile(
        inputstream    in,
        char[]         passphrase)
        throws ioexception, nosuchproviderexception, pgpexception
    {
        in = pgputil.getdecoderstream(in);
        
        pgpobjectfactory        pgpf = new pgpobjectfactory(in);
        pgpencrypteddatalist    enc;
        object                  o = pgpf.nextobject();
        
        //
        // the first object might be a pgp marker packet.
        //
        if (o instanceof pgpencrypteddatalist)
        {
            enc = (pgpencrypteddatalist)o;
        }
        else
        {
            enc = (pgpencrypteddatalist)pgpf.nextobject();
        }

        pgppbeencrypteddata     pbe = (pgppbeencrypteddata)enc.get(0);

        inputstream clear = pbe.getdatastream(new jcepbedatadecryptorfactorybuilder(new jcapgpdigestcalculatorproviderbuilder().setprovider("bc").build()).setprovider("bc").build(passphrase));
        
        pgpobjectfactory        pgpfact = new pgpobjectfactory(clear);

        //
        // if we're trying to read a file generated by someone other than us
        // the data might not be compressed, so we check the return type from
        // the factory and behave accordingly.
        //
        o = pgpfact.nextobject();
        if (o instanceof pgpcompresseddata)
        {
            pgpcompresseddata   cdata = (pgpcompresseddata)o;

            pgpfact = new pgpobjectfactory(cdata.getdatastream());

            o = pgpfact.nextobject();
        }
        
        pgpliteraldata ld = (pgpliteraldata)o;
        inputstream unc = ld.getinputstream();

        outputstream fout = new bufferedoutputstream(new fileoutputstream(ld.getfilename()));

        streams.pipeall(unc, fout);

        fout.close();

        if (pbe.isintegrityprotected())
        {
            if (!pbe.verify())
            {
                system.err.println("message failed integrity check");
            }
            else
            {
                system.err.println("message integrity check passed");
            }
        }
        else
        {
            system.err.println("no message integrity check");
        }
    }

    private static void encryptfile(
        string          outputfilename,
        string          inputfilename,
        char[]          passphrase,
        boolean         armor,
        boolean         withintegritycheck)
        throws ioexception, nosuchproviderexception
    {
        outputstream out = new bufferedoutputstream(new fileoutputstream(outputfilename));
        encryptfile(out, inputfilename, passphrase, armor, withintegritycheck);
        out.close();
    }

    private static void encryptfile(
        outputstream    out,
        string          filename,
        char[]          passphrase,
        boolean         armor,
        boolean         withintegritycheck)
        throws ioexception, nosuchproviderexception
    {
        if (armor)
        {
            out = new armoredoutputstream(out);
        }

        try
        {
            byte[] compresseddata = pgpexampleutil.compressfile(filename, compressionalgorithmtags.zip);

            pgpencrypteddatagenerator encgen = new pgpencrypteddatagenerator(new jcepgpdataencryptorbuilder(pgpencrypteddata.cast5)
                .setwithintegritypacket(withintegritycheck).setsecurerandom(new securerandom()).setprovider("bc"));

            encgen.addmethod(new jcepbekeyencryptionmethodgenerator(passphrase).setprovider("bc"));

            outputstream encout = encgen.open(out, compresseddata.length);

            encout.write(compresseddata);
            encout.close();

            if (armor)
            {
                out.close();
            }
        }
        catch (pgpexception e)
        {
            system.err.println(e);
            if (e.getunderlyingexception() != null)
            {
                e.getunderlyingexception().printstacktrace();
            }
        }
    }

    public static void main(
        string[] args)
        throws exception
    {
        security.addprovider(new bouncycastleprovider());

        if (args[0].equals("-e"))
        {
            if (args[1].equals("-a") || args[1].equals("-ai") || args[1].equals("-ia"))
            {
                encryptfile(args[2] + ".asc", args[2], args[3].tochararray(), true, (args[1].indexof('i') > 0));
            }
            else if (args[1].equals("-i"))
            {
                encryptfile(args[2] + ".bpg", args[2], args[3].tochararray(), false, true);
            }
            else
            {
                encryptfile(args[1] + ".bpg", args[1], args[2].tochararray(), false, false);
            }
        }
        else if (args[0].equals("-d"))
        {
            decryptfile(args[1], args[2].tochararray());
        }
        else
        {
            system.err.println("usage: pbefileprocessor -e [-ai]|-d file passphrase");
        }
    }
}

package org.ripple.bouncycastle.crypto.engines;

import java.util.hashtable;

import org.ripple.bouncycastle.crypto.blockcipher;
import org.ripple.bouncycastle.crypto.cipherparameters;
import org.ripple.bouncycastle.crypto.datalengthexception;
import org.ripple.bouncycastle.crypto.outputlengthexception;
import org.ripple.bouncycastle.crypto.params.keyparameter;
import org.ripple.bouncycastle.crypto.params.parameterswithsbox;
import org.ripple.bouncycastle.util.arrays;
import org.ripple.bouncycastle.util.strings;

/**
 * implementation of gost 28147-89
 */
public class gost28147engine
    implements blockcipher
{
    protected static final int  block_size = 8;
    private int[]               workingkey = null;
    private boolean forencryption;

    private byte[] s = sbox_default;

    // these are the s-boxes given in applied cryptography 2nd ed., p. 333
    // this is default s-box!
    private static byte sbox_default[] = {
        0x4,0xa,0x9,0x2,0xd,0x8,0x0,0xe,0x6,0xb,0x1,0xc,0x7,0xf,0x5,0x3,
        0xe,0xb,0x4,0xc,0x6,0xd,0xf,0xa,0x2,0x3,0x8,0x1,0x0,0x7,0x5,0x9,
        0x5,0x8,0x1,0xd,0xa,0x3,0x4,0x2,0xe,0xf,0xc,0x7,0x6,0x0,0x9,0xb,
        0x7,0xd,0xa,0x1,0x0,0x8,0x9,0xf,0xe,0x4,0x6,0xc,0xb,0x2,0x5,0x3,
        0x6,0xc,0x7,0x1,0x5,0xf,0xd,0x8,0x4,0xa,0x9,0xe,0x0,0x3,0xb,0x2,
        0x4,0xb,0xa,0x0,0x7,0x2,0x1,0xd,0x3,0x6,0x8,0x5,0x9,0xc,0xf,0xe,
        0xd,0xb,0x4,0x1,0x3,0xf,0x5,0x9,0x0,0xa,0xe,0x7,0x6,0x8,0x2,0xc,
        0x1,0xf,0xd,0x0,0x5,0x7,0xa,0x4,0x9,0x2,0x3,0xe,0x6,0xb,0x8,0xc
    };
    
    /*
     * class content s-box parameters for encrypting
     * getting from, see: http://tools.ietf.org/id/draft-popov-cryptopro-cpalgs-01.txt
     *                    http://tools.ietf.org/id/draft-popov-cryptopro-cpalgs-02.txt
     */
    private static byte[] esbox_test = {
         0x4,0x2,0xf,0x5,0x9,0x1,0x0,0x8,0xe,0x3,0xb,0xc,0xd,0x7,0xa,0x6,
         0xc,0x9,0xf,0xe,0x8,0x1,0x3,0xa,0x2,0x7,0x4,0xd,0x6,0x0,0xb,0x5,
         0xd,0x8,0xe,0xc,0x7,0x3,0x9,0xa,0x1,0x5,0x2,0x4,0x6,0xf,0x0,0xb,
         0xe,0x9,0xb,0x2,0x5,0xf,0x7,0x1,0x0,0xd,0xc,0x6,0xa,0x4,0x3,0x8,
         0x3,0xe,0x5,0x9,0x6,0x8,0x0,0xd,0xa,0xb,0x7,0xc,0x2,0x1,0xf,0x4,
         0x8,0xf,0x6,0xb,0x1,0x9,0xc,0x5,0xd,0x3,0x7,0xa,0x0,0xe,0x2,0x4,
         0x9,0xb,0xc,0x0,0x3,0x6,0x7,0x5,0x4,0x8,0xe,0xf,0x1,0xa,0x2,0xd,
         0xc,0x6,0x5,0x2,0xb,0x0,0x9,0xd,0x3,0xe,0x7,0xa,0xf,0x4,0x1,0x8
    };
    
    private static byte[] esbox_a = {
         0x9,0x6,0x3,0x2,0x8,0xb,0x1,0x7,0xa,0x4,0xe,0xf,0xc,0x0,0xd,0x5,
         0x3,0x7,0xe,0x9,0x8,0xa,0xf,0x0,0x5,0x2,0x6,0xc,0xb,0x4,0xd,0x1,
         0xe,0x4,0x6,0x2,0xb,0x3,0xd,0x8,0xc,0xf,0x5,0xa,0x0,0x7,0x1,0x9,
         0xe,0x7,0xa,0xc,0xd,0x1,0x3,0x9,0x0,0x2,0xb,0x4,0xf,0x8,0x5,0x6,
         0xb,0x5,0x1,0x9,0x8,0xd,0xf,0x0,0xe,0x4,0x2,0x3,0xc,0x7,0xa,0x6,
         0x3,0xa,0xd,0xc,0x1,0x2,0x0,0xb,0x7,0x5,0x9,0x4,0x8,0xf,0xe,0x6,
         0x1,0xd,0x2,0x9,0x7,0xa,0x6,0x0,0x8,0xc,0x4,0x5,0xf,0x3,0xb,0xe,
         0xb,0xa,0xf,0x5,0x0,0xc,0xe,0x8,0x6,0x2,0x3,0x9,0x1,0x7,0xd,0x4
    };
    
    private static byte[] esbox_b = {
         0x8,0x4,0xb,0x1,0x3,0x5,0x0,0x9,0x2,0xe,0xa,0xc,0xd,0x6,0x7,0xf,
         0x0,0x1,0x2,0xa,0x4,0xd,0x5,0xc,0x9,0x7,0x3,0xf,0xb,0x8,0x6,0xe,
         0xe,0xc,0x0,0xa,0x9,0x2,0xd,0xb,0x7,0x5,0x8,0xf,0x3,0x6,0x1,0x4,
         0x7,0x5,0x0,0xd,0xb,0x6,0x1,0x2,0x3,0xa,0xc,0xf,0x4,0xe,0x9,0x8,
         0x2,0x7,0xc,0xf,0x9,0x5,0xa,0xb,0x1,0x4,0x0,0xd,0x6,0x8,0xe,0x3,
         0x8,0x3,0x2,0x6,0x4,0xd,0xe,0xb,0xc,0x1,0x7,0xf,0xa,0x0,0x9,0x5,
         0x5,0x2,0xa,0xb,0x9,0x1,0xc,0x3,0x7,0x4,0xd,0x0,0x6,0xf,0x8,0xe,
         0x0,0x4,0xb,0xe,0x8,0x3,0x7,0x1,0xa,0x2,0x9,0x6,0xf,0xd,0x5,0xc
    };
    
    private static byte[] esbox_c = {
         0x1,0xb,0xc,0x2,0x9,0xd,0x0,0xf,0x4,0x5,0x8,0xe,0xa,0x7,0x6,0x3,
         0x0,0x1,0x7,0xd,0xb,0x4,0x5,0x2,0x8,0xe,0xf,0xc,0x9,0xa,0x6,0x3,
         0x8,0x2,0x5,0x0,0x4,0x9,0xf,0xa,0x3,0x7,0xc,0xd,0x6,0xe,0x1,0xb,
         0x3,0x6,0x0,0x1,0x5,0xd,0xa,0x8,0xb,0x2,0x9,0x7,0xe,0xf,0xc,0x4,
         0x8,0xd,0xb,0x0,0x4,0x5,0x1,0x2,0x9,0x3,0xc,0xe,0x6,0xf,0xa,0x7,
         0xc,0x9,0xb,0x1,0x8,0xe,0x2,0x4,0x7,0x3,0x6,0x5,0xa,0x0,0xf,0xd,
         0xa,0x9,0x6,0x8,0xd,0xe,0x2,0x0,0xf,0x3,0x5,0xb,0x4,0x1,0xc,0x7,
         0x7,0x4,0x0,0x5,0xa,0x2,0xf,0xe,0xc,0x6,0x1,0xb,0xd,0x9,0x3,0x8
    };
    
    private static byte[] esbox_d = {
         0xf,0xc,0x2,0xa,0x6,0x4,0x5,0x0,0x7,0x9,0xe,0xd,0x1,0xb,0x8,0x3,
         0xb,0x6,0x3,0x4,0xc,0xf,0xe,0x2,0x7,0xd,0x8,0x0,0x5,0xa,0x9,0x1,
         0x1,0xc,0xb,0x0,0xf,0xe,0x6,0x5,0xa,0xd,0x4,0x8,0x9,0x3,0x7,0x2,
         0x1,0x5,0xe,0xc,0xa,0x7,0x0,0xd,0x6,0x2,0xb,0x4,0x9,0x3,0xf,0x8,
         0x0,0xc,0x8,0x9,0xd,0x2,0xa,0xb,0x7,0x3,0x6,0x5,0x4,0xe,0xf,0x1,
         0x8,0x0,0xf,0x3,0x2,0x5,0xe,0xb,0x1,0xa,0x4,0x7,0xc,0x9,0xd,0x6,
         0x3,0x0,0x6,0xf,0x1,0xe,0x9,0x2,0xd,0x8,0xc,0x4,0xb,0xa,0x5,0x7,
         0x1,0xa,0x6,0x8,0xf,0xb,0x0,0x4,0xc,0x3,0x5,0x9,0x7,0xd,0x2,0xe
    };
    
    //s-box for digest
    private static byte dsbox_test[] = {
         0x4,0xa,0x9,0x2,0xd,0x8,0x0,0xe,0x6,0xb,0x1,0xc,0x7,0xf,0x5,0x3,
         0xe,0xb,0x4,0xc,0x6,0xd,0xf,0xa,0x2,0x3,0x8,0x1,0x0,0x7,0x5,0x9,
         0x5,0x8,0x1,0xd,0xa,0x3,0x4,0x2,0xe,0xf,0xc,0x7,0x6,0x0,0x9,0xb,
         0x7,0xd,0xa,0x1,0x0,0x8,0x9,0xf,0xe,0x4,0x6,0xc,0xb,0x2,0x5,0x3,
         0x6,0xc,0x7,0x1,0x5,0xf,0xd,0x8,0x4,0xa,0x9,0xe,0x0,0x3,0xb,0x2,
         0x4,0xb,0xa,0x0,0x7,0x2,0x1,0xd,0x3,0x6,0x8,0x5,0x9,0xc,0xf,0xe,
         0xd,0xb,0x4,0x1,0x3,0xf,0x5,0x9,0x0,0xa,0xe,0x7,0x6,0x8,0x2,0xc,
         0x1,0xf,0xd,0x0,0x5,0x7,0xa,0x4,0x9,0x2,0x3,0xe,0x6,0xb,0x8,0xc
    };
    
    private static byte dsbox_a[] = {
         0xa,0x4,0x5,0x6,0x8,0x1,0x3,0x7,0xd,0xc,0xe,0x0,0x9,0x2,0xb,0xf,
         0x5,0xf,0x4,0x0,0x2,0xd,0xb,0x9,0x1,0x7,0x6,0x3,0xc,0xe,0xa,0x8,
         0x7,0xf,0xc,0xe,0x9,0x4,0x1,0x0,0x3,0xb,0x5,0x2,0x6,0xa,0x8,0xd,
         0x4,0xa,0x7,0xc,0x0,0xf,0x2,0x8,0xe,0x1,0x6,0x5,0xd,0xb,0x9,0x3,
         0x7,0x6,0x4,0xb,0x9,0xc,0x2,0xa,0x1,0x8,0x0,0xe,0xf,0xd,0x3,0x5,
         0x7,0x6,0x2,0x4,0xd,0x9,0xf,0x0,0xa,0x1,0x5,0xb,0x8,0xe,0xc,0x3,
         0xd,0xe,0x4,0x1,0x7,0x0,0x5,0xa,0x3,0xc,0x8,0xf,0x6,0x2,0x9,0xb,
         0x1,0x3,0xa,0x9,0x5,0xb,0x4,0xf,0x8,0x6,0x7,0xe,0xd,0x0,0x2,0xc
    };
    
    //
    // pre-defined sbox table
    //
    private static hashtable sboxes = new hashtable();
    
    static
    {
        addsbox("default", sbox_default);
        addsbox("e-test", esbox_test);
        addsbox("e-a", esbox_a);
        addsbox("e-b", esbox_b);
        addsbox("e-c", esbox_c);
        addsbox("e-d", esbox_d);
        addsbox("d-test", dsbox_test);
        addsbox("d-a", dsbox_a);
    }

    private static void addsbox(string sboxname, byte[] sbox)
    {
        sboxes.put(strings.touppercase(sboxname), sbox);        
    }
    
    /**
     * standard constructor.
     */
    public gost28147engine()
    {
    }

    /**
     * initialise an gost28147 cipher.
     *
     * @param forencryption whether or not we are for encryption.
     * @param params the parameters required to set up the cipher.
     * @exception illegalargumentexception if the params argument is
     * inappropriate.
     */
    public void init(
        boolean           forencryption,
        cipherparameters  params)
    {
        if (params instanceof parameterswithsbox)
        {
            parameterswithsbox   param = (parameterswithsbox)params;

            //
            // set the s-box
            //
            byte[] sbox = param.getsbox();
            if (sbox.length != sbox_default.length)
            {
                throw new illegalargumentexception("invalid s-box passed to gost28147 init");
            }
            this.s = arrays.clone(sbox);

            //
            // set key if there is one
            //
            if (param.getparameters() != null)
            {
                workingkey = generateworkingkey(forencryption,
                        ((keyparameter)param.getparameters()).getkey());
            }
        }
        else if (params instanceof keyparameter)
        {
            workingkey = generateworkingkey(forencryption,
                                  ((keyparameter)params).getkey());
        }
        else if (params != null)
        {
           throw new illegalargumentexception("invalid parameter passed to gost28147 init - " + params.getclass().getname());
        }
    }

    public string getalgorithmname()
    {
        return "gost28147";
    }

    public int getblocksize()
    {
        return block_size;
    }

    public int processblock(
        byte[] in,
        int inoff,
        byte[] out,
        int outoff)
    {
        if (workingkey == null)
        {
            throw new illegalstateexception("gost28147 engine not initialised");
        }

        if ((inoff + block_size) > in.length)
        {
            throw new datalengthexception("input buffer too short");
        }

        if ((outoff + block_size) > out.length)
        {
            throw new outputlengthexception("output buffer too short");
        }

        gost28147func(workingkey, in, inoff, out, outoff);

        return block_size;
    }

    public void reset()
    {
    }

    private int[] generateworkingkey(
        boolean forencryption,
        byte[]  userkey)
    {
         this.forencryption = forencryption;

        if (userkey.length != 32)
        {
            throw new illegalargumentexception("key length invalid. key needs to be 32 byte - 256 bit!!!");
        }

        int key[] = new int[8];
        for(int i=0; i!=8; i++)
        {
            key[i] = bytestoint(userkey,i*4);
        }

        return key;
    }

    private int gost28147_mainstep(int n1, int key)
    {
        int cm = (key + n1); // cm1

        // s-box replacing

        int om = s[  0 + ((cm >> (0 * 4)) & 0xf)] << (0 * 4);
           om += s[ 16 + ((cm >> (1 * 4)) & 0xf)] << (1 * 4);
           om += s[ 32 + ((cm >> (2 * 4)) & 0xf)] << (2 * 4);
           om += s[ 48 + ((cm >> (3 * 4)) & 0xf)] << (3 * 4);
           om += s[ 64 + ((cm >> (4 * 4)) & 0xf)] << (4 * 4);
           om += s[ 80 + ((cm >> (5 * 4)) & 0xf)] << (5 * 4);
           om += s[ 96 + ((cm >> (6 * 4)) & 0xf)] << (6 * 4);
           om += s[112 + ((cm >> (7 * 4)) & 0xf)] << (7 * 4);

        return om << 11 | om >>> (32-11); // 11-leftshift
    }

    private void gost28147func(
        int[]   workingkey,
        byte[]  in,
        int     inoff,
        byte[]  out,
        int     outoff)
    {
        int n1, n2, tmp;  //tmp -> for saving n1
        n1 = bytestoint(in, inoff);
        n2 = bytestoint(in, inoff + 4);

        if (this.forencryption)
        {
          for(int k = 0; k < 3; k++)  // 1-24 steps
          {
            for(int j = 0; j < 8; j++)
            {
                tmp = n1;
                n1 = n2 ^ gost28147_mainstep(n1, workingkey[j]); // cm2
                n2 = tmp;
            }
          }
          for(int j = 7; j > 0; j--)  // 25-31 steps
          {
              tmp = n1;
              n1 = n2 ^ gost28147_mainstep(n1, workingkey[j]); // cm2
              n2 = tmp;
          }
        }
        else //decrypt
        {
          for(int j = 0; j < 8; j++)  // 1-8 steps
          {
             tmp = n1;
             n1 = n2 ^ gost28147_mainstep(n1, workingkey[j]); // cm2
             n2 = tmp;
          }
          for(int k = 0; k < 3; k++)  //9-31 steps
          {
            for(int j = 7; j >= 0; j--)
            {
                if ((k == 2) && (j==0))
                {
                    break; // break 32 step
                }
                tmp = n1;
                n1 = n2 ^ gost28147_mainstep(n1, workingkey[j]); // cm2
                n2 = tmp;
            }
          }
        }

        n2 = n2 ^ gost28147_mainstep(n1, workingkey[0]);  // 32 step (n1=n1)

        inttobytes(n1, out, outoff);
        inttobytes(n2, out, outoff + 4);
    }

    //array of bytes to type int
    private int bytestoint(
        byte[]  in,
        int     inoff)
    {
        return  ((in[inoff + 3] << 24) & 0xff000000) + ((in[inoff + 2] << 16) & 0xff0000) +
                ((in[inoff + 1] << 8) & 0xff00) + (in[inoff] & 0xff);
    }

    //int to array of bytes
    private void inttobytes(
            int     num,
            byte[]  out,
            int     outoff)
    {
            out[outoff + 3] = (byte)(num >>> 24);
            out[outoff + 2] = (byte)(num >>> 16);
            out[outoff + 1] = (byte)(num >>> 8);
            out[outoff] =     (byte)num;
    }
    
    /**
     * return the s-box associated with sboxname
     * @param sboxname name of the s-box
     * @return byte array representing the s-box
     */
    public static byte[] getsbox(
        string sboxname)
    {
        byte[] sbox = (byte[])sboxes.get(strings.touppercase(sboxname));

        if (sbox == null)
        {
            throw new illegalargumentexception("unknown s-box - possible types: "
                + "\"default\", \"e-test\", \"e-a\", \"e-b\", \"e-c\", \"e-d\", \"d-test\", \"d-a\".");
        }

        return arrays.clone(sbox);
    }
}
